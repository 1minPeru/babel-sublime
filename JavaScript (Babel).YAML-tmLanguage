# [PackageDev] target_format: plist, ext: tmLanguage
name: JavaScript (Babel)
scopeName: source.js
fileTypes: [js, jsx, babel, es6]
firstLineMatch: ^#!\s*/.*\b(node|js)$\n?

patterns:
- include: '#core'

repository:
  core:
    patterns:
    - include: '#literal-label'
    - include: '#literal-block'
    - include: '#literal-variable-declaration' # needs destructuring check
    - include: '#literal-keywords'
    - include: '#literal-for'
    - include: '#literal-switch'
    - include: '#literal-terminator'
    - include: '#expression'

  expression:
    patterns:
    - include: '#jsx'
    - include: '#literal-decorator'

    - include: '#support'
    - include: '#literal-function'
    - include: '#literal-function-assignment'
    - include: '#literal-function-storage'
    - include: '#literal-prototype'           # after literal-function, which includes some prototype strings

    - include: '#literal-regexp'              # before operators to avoid ambiguities
    - include: '#literal-number'
    - include: '#literal-quasi'
    - include: '#literal-string'
    - include: '#literal-language-builtin'

    - include: '#literal-method'
    - include: '#literal-module'
    - include: '#literal-class'

    - include: '#literal-constructor'
    - include: '#literal-method-call'
    - include: '#literal-function-call'

    - include: '#literal-object'

    - include: '#comments'

    - include: '#parenthesis'
    - include: '#square-brackets'

    - include: '#literal-operators'
    - include: '#literal-variable'

  parenthesis:
    patterns:
    - name: meta.group.round.js
      begin: \(
      end: \)
      captures:
        '0': {name: meta.brace.round.js}
      patterns:
      - include: '#expression'

  square-brackets:
    # TODO: don't forget computed props / backet prop notation
    patterns:
    - name: meta.group.square.js
      begin: \[
      end: \]
      captures:
        '0': {name: meta.brace.square.js}
      patterns:
      - include: '#expression'

  literal-object:
    patterns:
    - name: meta.object.js
      begin: \{
      end: \}
      captures:
        '0': {name: meta.brace.curly.js}
      patterns:
      - include: '#comments'

      - include: '#short-method'

      - name: meta.object.key.js
        match: \b([_$a-zA-Z][$\w]*)\b
        captures:
          '0': {name: string.unquoted.key.js}

      - name: meta.object.key.js
        contentName: string.quoted.key.js
        begin: (["'])
        beginCaptures:
          '0': {name: punctuation.definition.string.js}
        end: (\1)|(\n)
        endCaptures:
          '1': {name: punctuation.definition.string.js}
          '2': {name: invalid.illegal.newline.js}
        patterns:
        - include: '#string-content'

      - name: meta.object.computed-key.js
        begin: '\['
        end: '\]'
        captures:
          '0': {name: punctuation.definition.property.js}
        patterns:
        - include: '#expression'

      # Can't scope the computed short method as such because
      # we cheat when distringuishing between a computed key vs a computed
      # short method. `{[prop]: {}} vs {[prop](){}}`
      - begin: (?<=\])(?=\s*\()
        end: (?<=})
        patterns:
        - include: '#flowtype-polymorph'
        - include: '#function-declaration-parameters'
        - include: '#flowtype-return'
        - include: '#comments'
        - name: meta.function.body.js
          begin: '{'
          end: '}'
          patterns:
          - include: $self

      - name: meta.object.value.js
        begin: ':'
        beginCaptures:
          '0': {name: punctuation.separator.key-value.js}
        end: '(?=[,}])'
        patterns:
        - include: '#expression'

  literal-block:
    patterns:
    - name: meta.group.block.js
      begin: \{
      end: \}
      captures:
        '0': {name: meta.brace.curly.js}
      patterns:
      - include: $self

  comments:
    patterns:
    - name: comment.block.js
      begin: /\*
      end: \*/
      captures:
        '0': {name: punctuation.definition.comment.js}

    - name: comment.block.html.js
      match: (<!--|-->)
      captures:
        '0': {name: punctuation.definition.comment.js}

    - name: comment.line.double-slash.js
      match: (//).*$\n?
      captures:
        '1': {name: punctuation.definition.comment.js}

    - name: comment.line.shebang.js
      match: ^(#!).*$\n?
      captures:
        '1': {name: punctuation.definition.comment.js}

  function-declaration-parameters:
    patterns:
    - begin: \(
      end: \)
      captures:
        '0': {name: punctuation.definition.parameters.js}
      patterns:
      - include: '#function-parameters'
      - include: '#flowtype-variable'

  function-parameters:
    patterns:
    - name: keyword.operator.spread.js
      match: (?<!\.)\.\.\.
    - name: variable.parameter.function.js
      match: '[_$a-zA-Z][$\w]*'
    - name: punctuation.separator.parameter.function.js
      match: ','
    - name: meta.parameter.optional.js
      begin: '='
      beginCaptures:
        '0': {name: keyword.operator.assignment.js}
      end: '(?=[,)}\]])'
      patterns:
      - include: '#expression'
    - include: '#function-destructure'
    - include: '#comments'

  function-destructure:
    patterns:
    - begin: '\['
      end: '\]'
      captures:
        '0': {name: punctuation.definition.destructure.js}
      patterns:
      - include: '#function-parameters'
    - begin: '{'
      end: '}'
      captures:
        '0': {name: punctuation.definition.destructure.js}
      patterns:
      - include: '#function-parameters'

  function-storage:
    patterns:
    - include: '#literal-function-storage'
    - name: storage.type.function.js
      match: \b(function)\b
    - name: keyword.generator.asterisk.js
      match: '\*'

  function-right-side:
    patterns:
    - include: '#flowtype-polymorph'
    - include: '#function-declaration-parameters'
    - include: '#flowtype-return'
    - include: '#comments'

  short-method:
    # patterns:
    # - include: '#function-storage'
    patterns:
    - name: meta.method.js
      begin: >-
        (?x)
          (?:
          ((["'])((?:\\.|(?!\2).)*)(\2))  | # string quoted
          (?:\b([_$a-zA-Z][$\w]*)\b)      | # any identifier
          (?:\b(\d+)\b)                     # number-only name
          )(?=\<|\()
      beginCaptures:
        '1': {name: string.quoted.js}
        '2': {name: punctuation.definition.string.js}
        '3': {name: entity.name.function.js}
        '4': {name: string.quoted.js}
        '5': {name: entity.name.function.js}
        '6': {name: entity.name.function.js}
      end: (?<=})
      patterns:
      - include: '#flowtype-polymorph'
      - include: '#function-declaration-parameters'
      - include: '#flowtype-return'
      - include: '#comments'
      - name: meta.group.func-body.js
        begin: '{'
        end: '}'
        patterns:
        - include: $self

    # - name: meta.computed-shortmethod.js
    #   begin: (?<=\])(?=\s*\()
    #   end: (?<=})
    #   patterns:
    #   - include: '#flowtype-polymorph'
    #   - include: '#function-declaration-parameters'
    #   - include: '#flowtype-return'
    #   - include: '#comments'
    #   - name: meta.group.func-body.js
    #     begin: '{'
    #     end: '}'
    #     patterns:
    #     - include: $self

    # - contentName: meta.computed-method.js
    #   begin: (?=\[)
    #   end: (?={)
    #   patterns:
    #   - name: meta.group.curly.js
    #     begin: \{
    #     end: \}
    #     captures:
    #       '0': {name: meta.brace.curly.js}
    #     patterns:
    #     - include: $self
    #   - include: '#function-right-side'

  class-properties:
    patterns:
    - begin: (?=(?:[_$a-zA-Z][$\w]*)(?:\s|/\*.*\*/)*(?:=|:|;|\n))
      end: (?<=;|\n)
      patterns:
      - include: '#comments'
      - include: '#flowtype-variable'
      - include: '#literal-variable'
      - include: '#literal-operators'
      - include: '#literal-punctuation'
      - include: '#expression'

  literal-module:
    patterns:
    - name: keyword.operator.module.js
      match: (?<!\.)\b(?>import|export|default|from|as)\b

  literal-class:
    patterns:
    # e.g. class Sound extends Model { }
    - begin: (?<!\.)\b(class)\b
      beginCaptures:
        '0': {name: storage.type.class.js}
      end: (?<=})
      patterns:
      - begin: \b(extends)\b
        beginCaptures:
          '0': {name: storage.type.extends.js}
        end: (?={)
        patterns:
        - include: '#expression'
      - name: entity.name.class.js
        match: \b([_$a-zA-Z][$\w]*)\b
      - name: meta.class.js
        begin: '{'
        end: '}'
        captures:
          '0': {name: punctuation.section.class.js}
        patterns:
        - name: storage.modifier.js
          match: \b(static)\b
        - include: '#comments'
        - include: '#class-properties'
        - include: '#short-method'
        # - include: '#curly-brackets'
        - include: '#literal-decorator'

  literal-method:
    patterns:
    # e.g. play(arg1, arg2) {  }
    - name: meta.method.js
      begin: >-
        (?x)(?=
          (?:\b
            (?:async|\*|get|set)            # storage
            (?:\s|/\*.*\*/)+                # some gap
          )?
          (?:                               # es6 short-method identifier:
            (["'])(?:\\.|(?!\1).)*\1      | # string quoted
            (?:\b[_$a-zA-Z][$\w]*\b)      | # any identifier
            (?:\b\d+\b)                   | # number-only name
            (\[(?:(?>[^\[\]]+)|\g<-1>)*\])  # balanced brackets (computed name)
          )
          (?:\s|/\*.*\*/)*                  # maybe gap
          (\((?:(?>[^()]+)|\g<-1>)*\))      # balanced parens (arguments)
          (?:\s|/\*.*\*/)*                  # maybe gap
          (?:[:|{])                         # flowtype-return or function body
        )
      end: (?<=})
      patterns:
      - include: '#short-method'
      # - include: '#curly-brackets'

  literal-prototype:
    patterns:
    # e.g. "Sound =" or "Sound.* =" or "Sound.prototype.* ="
    - name: meta.function.class.js
      match: (?<!\.)\b(_?[A-Z][$\w]*)(?=(?:\.[_$a-zA-Z][$\w]*|\.prototype\.[_$a-zA-Z][$\w]*)\s*=)
      captures:
        '1': {name: entity.name.class.js}

  literal-function:
    patterns:
    # e.g. function play(arg1, arg2) { }
    - name: meta.function.js
      begin: (?:\b(async)\s+)?\b(function)\s*(\*)?\s*([_$a-zA-Z][$\w]*)?(?=\s*[<(])
      beginCaptures:
        '1': {name: storage.type.async.js}
        '2': {name: storage.type.function.js}
        '3': {name: keyword.generator.asterisk.js}
        '4': {name: entity.name.function.js}
      end: (?<=})
      patterns:
      - include: '#flowtype-polymorph'
      - include: '#function-declaration-parameters'
      - include: '#flowtype-return'
      - include: '#comments'
      - name: meta.group.func-body.js
        begin: '{'
        end: '}'
        patterns:
        - include: $self

    # e.g. arg => { }
    - name: meta.function.js # TODO: flowtype?
      match: (?:\b(async)\s+)?([_$a-zA-Z][$\w]*)\s*(=>)
      captures:
        '1': {name: storage.type.async.js}
        '2': {name: variable.parameter.js}
        '3': {name: storage.type.function.js}

    # e.g. (args) => { }
    - name: meta.function.js # TODO: '#flowtype-polymorph'?
      begin: (?:\b(async)\s+)?(?=(\((?:(?>[^()]+)|\g<-1>)*\))\s*(?::|=>))
      beginCaptures:
        '1': {name: storage.type.async.js}
      end: (=>)
      endCaptures:
        '1': {name: storage.type.function.js}
      patterns:
      - include: '#function-declaration-parameters'
      - include: '#flowtype-return'
      - include: '#comments'

  literal-function-assignment:
    # So "Goto Symbol" can work for assignments based on the identifier.
    # e.g. play = function play(arg1, arg2) { }
    # e.g. play = (args) => { }
    patterns:
    - name: meta.function.assignment.js
      match: >-
        (?x)
          ([_$a-zA-Z][$\w]*)
          (?=
            \s*=
            \s*(?:async\s+)?
            (?:
              (?:function\s*\*?\s*(?:[_$a-zA-Z][$\w]*)?\s*[<(]) |
              (?:(?:[_$a-zA-Z][$\w]*|(\((?:(?>[^()]+)|\g<-1>)*\)))\s*(?::|=>))
            )
          )
      captures:
        '1': {name: entity.name.function.js}

  literal-function-label:
    patterns:
    # So "Goto Symbol" can work for objects based on the key.
    # e.g. play: function(arg1, arg2) {  }
    # e.g. play: (args) => { }
    - name: meta.function.label.js
      match: >-
        (?x)
          (?:([_$a-zA-Z][$\w]*)|((["'])((?:\\.|(?!\3).)*)(\3)))\s*(:)
          (?=
            \s*(?:async\s+)?
            (?:
              (?:function\s*\*?\s*(?:[_$a-zA-Z][$\w]*)?\s*[<(]) |
              (?:(?:[_$a-zA-Z][$\w]*|(\((?:(?>[^()]+)|\g<-1>)*\)))\s*(?::|=>))
            )
          )
      captures:
        '1': {name: entity.name.function.js}
        '2': {name: string.quoted.js}
        '3': {name: punctuation.definition.string.js}
        '4': {name: entity.name.function.js}
        '5': {name: punctuation.definition.string.js}
        '6': {name: punctuation.separator.key-value.js}

  literal-function-call:
    patterns:
    - name: meta.function-call.without-arguments.js
      match: >-
        (?x)
          ([_$a-zA-Z][$\w]*)\s*
          (\(\s*\))
      captures:
        '1': {name: variable.function.js}
        '2': {name: meta.group.braces.round.function.arguments.js}

    - name: meta.function-call.with-arguments.js
      match: >-
        (?x)
          ([_$a-zA-Z][$\w]*)\s*
          (?=\()
      captures:
        '1': {name: variable.function.js}

    - name: meta.function-call.tagged-template-string.js
      match: ([_$a-zA-Z][$\w]*)\s*(?=`)
      captures:
        '1': {name: variable.function.js}

  literal-method-call:
    patterns:
    - name: meta.function-call.static.without-arguments.js
      match: >-
        (?x)
          (?:(?<=\.)|\b)
          ([A-Z][$\w]*)\s*(\.)
          ([_$a-zA-Z][$\w]*)\s*
          (\(\s*\))
      captures:
        '1': {name: variable.other.class.js}
        '2': {name: keyword.operator.accessor.js}
        '3': {name: variable.function.js}
        '4': {name: meta.group.braces.round.function.arguments.js}

    - name: meta.function-call.static.with-arguments.js
      match: >-
        (?x)
          (?:(?<=\.)|\b)
          ([A-Z][$\w]*)\s*(\.)
          ([_$a-zA-Z][$\w]*)\s*
          (?=\()
      captures:
        '1': {name: variable.other.class.js}
        '2': {name: keyword.operator.accessor.js}
        '3': {name: variable.function.js}

    - name: meta.function-call.method.without-arguments.js
      match: >-
        (?x)
          (?<=\.)
          ([_$a-zA-Z][$\w]*)\s*
          (\(\s*\))
      captures:
        '1': {name: variable.function.js}
        '2': {name: meta.group.braces.round.function.arguments.js}

    - name: meta.function-call.method.with-arguments.js
      match: >-
        (?x)
          (?<=\.)
          ([_$a-zA-Z][$\w]*)\s*
          (?=\()
      captures:
        '1': {name: variable.function.js}

  literal-language-builtin:
    patterns:
    - name: variable.language.js
      match: (?<!(?<!\.\.)\.)\b(?>arguments|self|super|this)\b
    - name: variable.language.js
      match: (?<=\.)\b(?>__proto__|constructor|prototype)\b
    - name: constant.language.js
      match: (?<!\.)\b(?>true|false|null|undefined|NaN)\b

  literal-constructor:
    patterns:
    - name: meta.instance.constructor
      begin: (new)\s+(?=[_$a-zA-Z][$\w.]*)
      beginCaptures:
        '1': {name: keyword.operator.new.js}
      end: (?![_$a-zA-Z][$\w.]*)
      patterns:
      - include: '#support'
      - match: ([_$a-zA-Z][$\w.]*\.)?([_$a-zA-Z][$\w]*)
        captures:
          '2': {name: variable.function.constructor.js}

  literal-function-storage:
    patterns:
    - name: storage.modifier.js
      match: \b(static)\b

    - name: storage.type.property.js
      match: \b(get|set)\b(?!\s*\()

    - name: storage.type.async.js
      match: \b(async)\b
      # should * also be here?

  literal-variable-declaration:
    patterns:
    - name: storage.type.js
      match: (?<!\.)\b(?>const|let|var)\b

  literal-keywords:
    patterns:
    # - include: '#literal-variable-declaration'
    # - include: '#literal-control'

    - name: keyword.control.flow.js
      match: (?<!\.)\b(?>return)\b

    - name: keyword.control.conditional.js
      match: (?<!\.)\b(?>if|else)\b

    - name: keyword.control.trycatch.js
      match: (?<!\.)\b(?>catch|finally|throw|try)\b

    - name: keyword.control.loop.js
      match: (?<!\.)\b(?>break|continue|do|goto|while)\b

    - name: keyword.other.js
      match: (?<!\.)\b(debugger)\b

  literal-control:
    patterns:
    - match: (?<!\.)\b(?>await|yield)\b(?:\s*(\*))?
      captures:
        '1': {name: keyword.control.flow.js}
        '2': {name: keyword.generator.asterisk.js}

  literal-for:
    patterns:
    - name: meta.for.js
      begin: (?<!\.)\b(for)\b
      beginCaptures:
        '1': {name: keyword.control.loop.js}
      end: \)
      endCaptures:
        '0': {name: meta.brace.round.js}
      patterns:
      - begin: \(
        beginCaptures:
          '0': {name: meta.brace.round.js}
        end: (?=\))
        patterns:
        - include: '#literal-variable-declaration'
        - include: '#expression'
        - include: '#literal-punctuation'

  literal-switch:
    patterns:
    - name: meta.switch.js
      begin: (?<!\.)\b(switch)\b
      beginCaptures:
        '1': {name: keyword.control.switch.js}
      end: \}
      endCaptures:
        '0': {name: meta.brace.curly.js}
      patterns:
      - include: '#parenthesis'
      - begin: \{
        beginCaptures:
          '0': {name: meta.brace.curly.js}
        end: (?=})
        patterns:
        - begin: (?<!\.)\b(case|default)\b
          beginCaptures:
            '1': {name: keyword.control.switch.js}
          end: (?=:)
          patterns:
          - include: '#expression'
        - include: $self

  literal-operators:
    patterns:
    - name: keyword.operator.js
      match: '=>'

    - name: keyword.operator.js
      match: (?<!\.)\b(?>delete|instanceof|in|new|of|typeof|void|with)\b

    - name: keyword.operator.logical.js
      match: >-
        (?x)
          !(?!=)| # logical-not     right-to-left   right
          &&    | # logical-and     left-to-right   both
          \|\|  | # logical-or      left-to-right   both

    # - name: keyword.operator.assignment.js
    #   match: >-
    #     (?x)
    #       =(?!=)| # assignment      right-to-left   both

    - begin: >-
        (?x)
          =(?!=) # assignment      right-to-left   both
      beginCaptures:
        '0': {name: keyword.operator.assignment.js}
      end: (?=;|\n)
      patterns:
      - include: '#expression'

    - name: keyword.operator.assignment.augmented.js
      match: >-
        (?x)
          %=   | # assignment      right-to-left   both
          &=   | # assignment      right-to-left   both
          \*=  | # assignment      right-to-left   both
          \+=  | # assignment      right-to-left   both
          -=   | # assignment      right-to-left   both
          /=   | # assignment      right-to-left   both
          \^=  | # assignment      right-to-left   both
          \|=  | # assignment      right-to-left   both
          <<=  | # assignment      right-to-left   both
          >>=  | # assignment      right-to-left   both
          >>>= | # assignment      right-to-left   both

    - name: keyword.operator.bitwise.js
      match: >-
        (?x)
          ~    | # bitwise-not     right-to-left   right
          <<   | # bitwise-shift   left-to-right   both
          >>>  | # bitwise-shift   left-to-right   both
          >>   | # bitwise-shift   left-to-right   both
          &    | # bitwise-and     left-to-right   both
          \^   | # bitwise-xor     left-to-right   both
          \|     # bitwise-or      left-to-right   both

    - name: keyword.operator.relational.js
      match: >-
        (?x)
          <=   | # relational      left-to-right   both
          >=   | # relational      left-to-right   both
          <    | # relational      left-to-right   both
          >      # relational      left-to-right   both

    - name: keyword.operator.comparison.js
      match: >-
        (?x)
          ===  | # equality        left-to-right   both
          !==  | # equality        left-to-right   both
          ==   | # equality        left-to-right   both
          !=     # equality        left-to-right   both

    - name: keyword.operator.arithmetic.js
      match: >-
        (?x)
          --   | # decrement       n/a             right-or-left
          \+\+ | # increment       n/a             right-or-left
          /    | # division        left-to-right   both
          %    | # modulus         left-to-right   both
          \*   | # multiplication  left-to-right   both
          \+   | # addition        left-to-right   both
          -      # subtraction     left-to-right   both

    - name: keyword.operator.ternary.js
      match: '\?|:'

    - name: keyword.operator.spread.js
      match: (?<!\.)\.\.\.

    - name: keyword.operator.accessor.js
      match: \.

  literal-label:
    patterns:
    - name: constant.other.object.key.js
      match: (?<!\.|\?|\?\s)([_$a-zA-Z][$\w]*)\s*(:)
      captures:
        '1': {name: string.unquoted.label.js}
        '2': {name: punctuation.separator.key-value.js}

  literal-number:
    patterns:
    - name: invalid.illegal.numeric.hex.js
      match: (?i)(?:\B[-+]|\b)0x[0-9a-f]*\.(\B|\b[0-9]+)

    - name: invalid.illegal.numeric.octal.js
      match: (?:\B[-+]|\b)0[0-9]+\.(\B|\b[0-9]+)

    - name: constant.numeric.js
      match: >-
        (?xi)
          (?:\B[-+])?
          (?:
            \b0b[0-1]*|                 # binary
            \b0o[0-7]*|                 # octal
            \b0x[0-9a-f]*|              # hex
            (
              \B\.[0-9]+|               # e.g. .999
              \b[0-9]+(\.[0-9]*)?       # e.g. 999.999, 999. or 999
            )(e[-+]?[0-9]+)?            # e.g. e+123, E-123
          )

    - name: constant.language.infinity.js
      match: (?:\B[-+]|\b)(Infinity)\b

  literal-terminator:
    patterns:
    - name: punctuation.terminator.statement.js
      match: ';'

  literal-punctuation:
    patterns:
    - name: punctuation.terminator.statement.js
      match: ';'

    - name: meta.delimiter.comma.js
      match: ','

  literal-quasi:
    begin: '`'
    end: '`'
    captures:
      '0': {name: punctuation.definition.quasi.js}
    patterns:
    - include: '#string-content'
    - include: '#quasi-content'
    # interpolated expressions aren't scoped as "string" so themes don't color
    # them as such
    - name: string.quasi.js
      match: '.'

  quasi-content:
    patterns:
    - name: constant.character.escape.js
      match: '\\`'
    - begin: '\${'
      end: '}'
      captures:
        '0': {name: keyword.operator.substitution.js}
      patterns:
      - include: '#expression'

  literal-regexp:
    patterns:
    # ignore ++, -- since they're uncommon, distinguishing them is not possible in sublime text, see:
    # http://stackoverflow.com/questions/5519596/when-parsing-javascript-what-determines-the-meaning-of-a-slash
    - name: string.regexp.js
      begin: >-
        (?x)
          (?<=
            \.|\(|,|{|}|\[|;|,|<|>|<=|>=|==|!=|===|!==|\+|-|\*|%|\+\+|--|<<|>>|>>>|&|\||\^|!|~|&&|\|\||\?|:|=|\+=|-=|\*=|%=|<<=|>>=|>>>=|&=|\|=|\^=|/|/=|
            \Wnew|\Wdelete|\Wvoid|\Wtypeof|\Winstanceof|\Win|\Wdo|\Wreturn|\Wcase|\Wthrow|
            ^new|^delete|^void|^typeof|^instanceof|^in|^do|^return|^case|^throw|^
          )\s*
          (/)
          (?!/|\*|$)
      beginCaptures:
        '1': {name: punctuation.definition.string.begin.js}
      end: (/)([gimy]*)
      endCaptures:
        '1': {name: punctuation.definition.string.end.js}
        '2': {name: keyword.other.js}
      patterns:
      - include: source.regexp.js

  literal-string:
    patterns:
    - name: string.quoted.js
      begin: (["'])
      beginCaptures:
        '0': {name: punctuation.definition.string.js}
      end: (\1)|(\n)
      endCaptures:
        '1': {name: punctuation.definition.string.js}
        '2': {name: invalid.illegal.newline.js}
      patterns:
      - include: '#string-content'

  string-content:
    patterns:
    - name: constant.character.escape.newline.js
      match: \\\s*\n
    # https://mathiasbynens.be/notes/javascript-escapes
    - name: constant.character.escape.js
      match: \\([1-7][0-7]{0,2}|[0-7]{2,3}|[bfnrtv0'"\\]|x\h{2}|u\{\h+\}|u\h{4})

  literal-variable:
    patterns:
    # e.g. CONSTANT
    - name: variable.other.constant.js
      match: '[A-Z][_$\dA-Z]*\b'

    # e.g. Class.property
    - name: meta.property.class.js
      match: >-
        (?x)
          (?<!\.)\b(_?[A-Z][$\w]*)(?=\s*\.[_$a-zA-Z][$\w]*)
      captures:
        '1': {name: variable.other.class.js}

    # e.g. "obj." or "obj[]"
    - name: variable.other.object.js
      match: (?<!\.)([_$a-zA-Z][$\w]*)\s*(?=[\[\.])
      captures:
        '1': {name: variable.other.object.js}

    # e.g. obj.property
    - name: meta.property.object.js
      match: (?<=\.)\s*([_$a-zA-Z][$\w]*)
      captures:
        '1': {name: variable.other.property.js}

    - name: variable.other.readwrite.js
      match: '[_$a-zA-Z][$\w]*'

  support:
    # https://github.com/sindresorhus/globals
    patterns:
    - name: support.class.builtin.js
      match: \b(Array|ArrayBuffer|Boolean|DataView|Date|Error|EvalError|Float32Array|Float64Array|Function|Infinity|Int16Array|Int32Array|Int8Array|JSON|Map|Math|NaN|Number|Object|Promise|Proxy|RangeError|ReferenceError|Reflect|RegExp|Set|String|Symbol|SyntaxError|System|TypeError|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|URIError|WeakMap|WeakSet)\b

    - name: support.class.node.js
      match: \b(Buffer)\b

    - name: support.function.builtin.js
      match: (?<!\.)\b(constructor|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|hasOwnProperty|isFinite|isNaN|isPrototypeOf|parseFloat|parseInt|propertyIsEnumerable|toLocaleString|toString|undefined|unescape|valueOf)\b

    - name: support.function.node.js
      match: (?<!\.)\b(clearImmediate|clearInterval|clearTimeout|require|setImmediate|setInterval|setTimeout)\b

    - name: support.type.object.dom.js
      match: (?<!\.)\b(document|window)\b

    - name: support.type.object.node.js
      match: (?<!\.)\b(global|GLOBAL|root|__dirname|__filename)\b

    - match: (?<!\.)\b(console)(?:(\.)(assert|count|dir|error|group|groupCollapsed|groupEnd|info|log|profile|profileEnd|table|time|timeEnd|trace|warn))?\b
      captures:
        '1': {name: support.type.object.console.js}
        '2': {name: keyword.operator.accessor.js}
        '3': {name: support.function.console.js}

    - match: (?<!\.)\b(process)(?:(\.)(?:(arch|argv|config|env|execArgv|execPath|exitCode|mainModule|pid|platform|stderr|stdin|stdout|title|version|versions)|(abort|chdir|cwd|exit|getgid|getgroups|getuid|hrtime|initgroups|kill|memoryUsage|nextTick|setgid|setgroups|setuid|umask|uptime)))?\b
      captures:
        '1': {name: support.type.object.process.js}
        '2': {name: keyword.operator.accessor.js}
        '3': {name: support.type.object.process.js}
        '4': {name: support.function.process.js}

    - match: (?<!\.)\b(exports|module(?:(\.)(children|exports|filename|id|loaded|parent)))?\b
      captures:
        '1': {name: support.type.object.module.js}
        '2': {name: keyword.operator.accessor.js}
        '3': {name: support.type.object.module.js}

  # https://github.com/wycats/javascript-decorators
  literal-decorator:
    patterns:
    - name: tag.decorator.js
      match: >-
        (?x)
          (@)([_$a-zA-Z][$\w]*)\b
      captures:
        '1': {name: punctuation.definition.tag.js}
        '2': {name: entity.name.tag.js}

################################################################################
## jsx
################################################################################

  jsx:
    contentName: meta.jsx.js
    begin: (?<=\(|\{|\[|,|&&|\|\||\?|:|=|=>|\Wreturn|^return|^)\s*(?=<)
    end: (?<=/>|>)
    patterns:
    - include: '#jsx-tag-start'

  jsx-tag-start:
    patterns:
    - begin: (<)([_$a-zA-Z][-$:.\w]*[$\w]*)
      beginCaptures:
        '1': {name: punctuation.definition.tag.jsx}
        '2': {name: entity.name.tag.jsx}
      end: (</)(\2)(>)|(/>)
      endCaptures:
        '1': {name: punctuation.definition.tag.jsx}
        '2': {name: entity.name.tag.jsx}
        '3': {name: punctuation.definition.tag.jsx}
        '4': {name: punctuation.definition.tag.jsx}
      patterns:
      - include: '#comments'
      - include: '#jsx-tag-end'
      - include: '#jsx-attributes'

    - name: invalid.illegal.tag.incomplete.jsx
      match: '<'

  jsx-tag-end:
    begin: '>'
    beginCaptures:
      '0': {name: punctuation.definition.tag.jsx}
    end: (?=</)
    patterns:
    - include: '#jsx-tag-start'
    - include: '#jsx-evaluated-code'
    - include: '#jsx-entities'

  jsx-attributes:
    patterns:
    - include: '#jsx-attribute-name'
    - include: '#jsx-attribute-assignment'
    - include: '#jsx-string-quoted'
    - include: '#jsx-evaluated-code'
    - include: '#jsx-attribute-illegal'

  jsx-attribute-name:
    name: entity.other.attribute-name.jsx
    match: '[_$a-zA-Z][-$\w]*'

  jsx-attribute-assignment:
    name: keyword.operator.assignment.jsx
    match: '='

  jsx-evaluated-code:
    name: meta.embedded.expression.jsx
    begin: '{'
    end: '}'
    captures:
      '0': {name: punctuation.section.embedded.jsx}
    patterns:
    - include: '#expression'

  jsx-string-quoted:
    name: string.quoted.jsx
    begin: (["'])
    end: (\1)
    captures:
      '0': {name: punctuation.definition.string.jsx}
    patterns:
    - include: '#jsx-entities'

  jsx-entities:
    patterns:
    - name: constant.character.entity.jsx
      match: '&(?:[a-zA-Z0-9]+|#\d+|#x\h+);'
    - name: invalid.illegal.bad-ampersand.jsx
      match: '&\S*;'

  jsx-attribute-illegal:
    name: invalid.illegal.attribute.jsx
    match: \S*

################################################################################
## flow
################################################################################

  flowtype-polymorph:
    contentName: meta.flowtype.js
    begin: '<'
    end: '>'
    captures:
      '0': {name: keyword.operator.flowtype.js}
    patterns:
    - include: '#flowtype-tokens'

  flowtype-variable:
    contentName: meta.flowtype.js
    begin: ':'
    # a line-comment is also a terminator since semicolons are optional
    end: (?=,|;|\)|\n|\s*\/\/)
    captures:
      '0': {name: keyword.operator.flowtype.js}
    patterns:
    - include: '#flowtype-tokens'

  flowtype-return:
    contentName: meta.flowtype.js
    begin: ':'
    end: (?=\s*{)
    captures:
      '0': {name: keyword.operator.flowtype.js}
    patterns:
    - include: '#flowtype-tokens'

  flowtype-tokens:
    patterns:
    - name: constant.other.primitve.flowtype.js
      match: \b(?:any|bool|boolean|mixed|number|string|void)\b

    - name: support.type.builtin.class.flowtype.js
      match: \b(?:Array|ArrayBuffer|Boolean|DataView|Date|Error|EvalError|Float32Array|Float64Array|Function|Infinity|Int16Array|Int32Array|Int8Array|JSON|Map|Math|NaN|Number|Object|Promise|Proxy|RangeError|ReferenceError|Reflect|RegExp|Set|String|Symbol|SyntaxError|System|TypeError|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|URIError|WeakMap|WeakSet)\b

    - name: support.type.node.class.flowtype.js
      match: \b(?:Buffer)\b

    - name: variable.other.flowtype.js
      match: '[_$a-zA-Z][$\w]*'

    - name: punctuation.separator.flowtype.js
      match: (\:|\?|\||\&|\*|=>)

    - include: '#comments'

    - begin: (?<=:)\s*({)
      end: (})
      captures:
        '1': {name: punctuation.section.flowtype.js}
      patterns:
      - include: '#flowtype-tokens'

    - begin: '<'
      end: '>'
      captures:
        '0': {name: punctuation.section.flowtype.js}
      patterns:
      - include: '#flowtype-tokens'

    - begin: '\('
      end: '\)'
      captures:
        '0': {name: punctuation.section.flowtype.js}
      patterns:
      - include: '#flowtype-tokens'
